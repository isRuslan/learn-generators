Обработка ошибок и генераторы.

## Теория
Лучшее, что генераторы принесли нам это **синхронность**. Код внутри генераторов
является синхронным, даже если мы вызываем генератор в асинхронном режиме.

Это означает, что мы можем использовать конструкцию `try {...} catch () {}` с легкостью.

```js
function *dummy () {
  try {
    null.foo(); // вызываем exception
  } catch (e) {
    console.log('Caught exception: %s', e);
  }
  yield 'Попали сюда без сбоев';
}
dummy().next();
// Caught exception: TypeError: Cannot read property 'foo' of null
{ value: 'Попали сюда без сбоев', done: false }
```
Также, функция-генератор имеет `throw()` метод, который позволяет отправить
исключение внутрь функции, позволяя конструкции `try-catch` отловить исключение
внутри генератора.

Помните: если внутри генератора нет конструкции `try-catch`, то послыаемое
исключение будет просто возвращено из функции.

```js
function *foo () { yield 'inside foo'; }

var it = foo();
try {
  it.throw('BOOO from outside');
} catch (errFromIt) {
  console.log('Error: %s ', errFromIt); // Error: BOOO from outside
}
```

## Задание
Реализуйте функцию-генератор `upper`, которая принимает массив строк
на вход и вызвращает каждую строк в верхнем регистре.

**Проблема:** кто-то послал число в `upper` и это сломало всю работу.
Пожалуйста исправьте это. Если `upper` получил число, то он должен вернуть `null`.

**Шаблон решения:**

```js
function *upper (items) {
  // ваш код здесь
}

var bad_items = ['a', 'B', 1, 'c'];

for (var item of upper(bad_items)) {
  console.log(item);
}
// вывод: A, B, null, C
```
